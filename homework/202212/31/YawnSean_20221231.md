### 规范化 $Unicode$ 字符串

- $Unicode$ 有组合字符，比较起来相对复杂（可能有长得一样的字符串编码不同）。（$combining acute accent$ 可能带来标准等价物）

- 解决方式：使用 `unicodedata.normalize` 函数进行规范化，第一个参数在 `NFC`, `NFD`, `NFKC`, `NFKD` 中选取。

- `NFC` 使用最少的码位构成等价的字符串，`NFD` 把组合字符分解成基字符和单独的组合字符。

- 西方键盘通常能输出组合字符，因此用户输入的文本默认是 `NFC` 形式，但安全起见最好使用规范化进行清洗；使用时，可能会让一个单字符规范为另一个单字符，虽然视觉上一样但是比较时并不相等，。

- `K` 表示兼容性，有较严格的规范化形式，每个兼容字符会被替换为一个或多个“兼容分解”字符；可能会带来格式损失，损失或曲解信息，但可以为搜索和索引提供便利的中间表述。

### 搜索或索引准备文本

- 大小写折叠：把文本均变为小写，`str.casefold()`。相比于 `str.lower()` 的差别：微符号会变为希腊字母，德语 $sharp s$ 变为 `"ss"` 等，不同的占比相对较小。不同语言有许多特殊情况。

- 规范化文本匹配：多语言文本 ——  `nfc_equal`, `fold_equal`。（后者不考虑大小写）

- 极端规范化：去掉变音符号。不是正确的规范化方式，因为可能改变词义，但现实中可能恰好匹配一些错误，也可以让 $URL$ 便于阅读。有许多相关处理（但感觉暂时用不到就不理了）。