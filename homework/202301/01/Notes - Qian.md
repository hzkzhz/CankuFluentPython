# dict

- dict的键必须是可散列的: 如果你实现了一个类的 __eq__ 方法，并且希望它是可散列的，那么它一定要 有个恰当的 __hash__ 方法，保证在 a == b 为真的情况下 hash(a) == hash(b) 也必定为真。
- 字典在内存上的开销巨大: 列表又必须是稀疏的，这导致它在空间上的效率低下。
- dict 的实现是典型的空间换时间:字典类型有着巨大的内存开销，但它们提供了无视数据 量大小的快速访问——只要字典能被装在内存里。
- 键的次序取决于添加顺序: 即便是给key或者value进行了排序，依然不改变这个dict。That means it equals to another dict with the same key+value pairs.
- 往集合里添加元素，可能会改变集合里已有元素的次序。

## set 和 frozenset 的实现也依赖散列表
它们的散列表里存放的只有元素的引用(就 像在字典里只存放键而没有相应的值)。在 set 加入到 Python 之前，我们都是把字典加上 无意义的值当作集合来用的。

# 在映射类型的 API 中，有个很好用的方法是 __missing__，当对象找不到某个键的时候，可以通过这个方法自定义会发生什么。

