函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为。这是一项强大的功
能，但是若想掌握，必须理解闭包。
nonlocal 是新近出现的保留关键字，在 Python 3.0 中引入。作为 Python 程序员，如果严格
遵守基于类的面向对象编程方式，即便不知道这个关键字也不会受到影响。然而，如果你
想自己实现函数装饰器，那就必须了解闭包的方方面面，因此也就需要知道 nonlocal。

装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。2 装饰器可能会处理被装
饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。
假如有个名为 decorate 的装饰器：
```python
@decorate
def target():
print('running target()')
```
上述代码的效果与下述写法一样：
```python
def target():
print('running target()')
target = decorate(target)
```
两种写法的最终结果一样：上述两个代码片段执行完毕后得到的 target 不一定是原来那个
target 函数，而是 decorate(target) 返回的函数。

严格来说，装饰器只是语法糖。如前所示，装饰器可以像常规的可调用对象那样调用，其参
数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。
综上，装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器
在加载模块时立即执行。

装饰器不会检查是否返回的仍然是函数，它只是机械地替换，例如下面这个例子：
例如：
```python
def x(func):
    return func()+1

@x
def xx():
    return 3

print(xx)

def f():
    return 2

print(type(f))
print(type(xx))
```