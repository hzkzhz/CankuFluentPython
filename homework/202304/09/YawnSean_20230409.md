- 只有异步应用程序低层的事件循环能依靠基础设置的终端、线程、轮询和后台进程点，确保多个并发请求能取得进展并最终完成才能使用回调。

- 异步编程的另一种方式：把生成器当做协程使用。对于时间循环来说，调用回调与在暂停协程上调用 `.send()` 类似。暂停的协程小号内存，但是比线程数量极小。

- `asyncio` 调用后比原始版本更快的原因：本来依序下载，每次都需要极多的 CPU 周期等待结果；而调用后，事件循环驱动协程——运行第一层到第一个 `yield from` 表达式处，不断往下到各个协程，请求是几乎同时发出的。

- 因为异步操作交叉执行，用时比依序下载少的多。