# notes

内置类型子类化时并没有出问题，只是由于我们没有认清特殊方法（C 语言实现的方法）的真面目，才会导致结果偏差。

那么，这又召唤出了一个新的问题：如果非要继承内置类型，最佳的实践方式是什么呢？

首先，如果在继承内置类型后，并不重写（overwrite）它的特殊方法的话，子类化就不会有任何问题。

其次，如果继承后要重写特殊方法的话，记得要把所有希望改变的方法都重写一遍，例如，如果想改变 get() 方法，就要重写 get() 方法，如果想改变 __getitem__()方法，就要重写它……

但是，如果我们只是想重写某种逻辑（即 C 语言的部分），以便所有用到该逻辑的特殊方法都发生改变的话，例如重写__setitem__()的逻辑，同时令初始化和update()等操作跟着改变，那么该怎么办呢？

我们已知特殊方法间不存在复用，也就是说单纯定义新的__setitem__()是不够的，那么，怎么才能对多个方法同时产生影响呢？

PyPy 这个非官方的 Python 版本发现了这个问题，它的做法是令内置类型的特殊方法发生调用，建立它们之间的连接通路。

官方 Python 当然也意识到了这么问题，不过它并没有改变内置类型的特性，而是提供出了新的方案：UserString、UserList、UserDict……