#### 重写 Sentence 类的学习

- 为何不应该把可迭代对象写成迭代器：为了支持多种遍历，需要从一个可迭代的实例中获得多个独立的迭代器。（否则这个实例将只能迭代一次）

- 可迭代的对象一定不能是自身的迭代器，必须实现 `__iter__`，不能实现 `__next__`。为了迭代器一直迭代，迭代器（注意，不是可迭代对象，可迭代对象的应该返回一个迭代器）的 `__iter__` 方法返回自身。

- 另一种实现方式：使用生成器函数替代一个迭代器的类：`yield` 每个元素，最后返回不返回 `return` 都可以。这里的迭代器是一个生成器对象，每次调用 `__iter__` 方法都会自动创建。

- 只要函数定义体中有 `yield` 关键字，都是生成器函数，调用之会返回迭代器接口的生成器对象，包装生成器函数的定义体。

- 传给 `next(...)` 函数时，函数向前，执行定义体中的下一个 `yield` 语句，返回产出值并暂停，最后定义体返回时，外层生成器对象抛出 `StopIteration` 异常。函数中的 `return` 语句也会触发这样的异常。

- 最后的优化：惰性实现，尽可能延后生成数值，避免进行无用的处理。